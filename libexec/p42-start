#!/usr/bin/env bash

include machine
include aws
include docker
include context

_pull() {

  local cluster image
  local "${@}"

  echo "Pulling image '${image}' onto Swarm nodes..."

  for node in $(list_swarm_nodes "${cluster}"); do
    echo "- ${node}"
    docker_env "${node}"
    docker_login
    docker pull ${registry}/${image}:latest
  done

}

_run() {

  local part image config count subdomains
  local "${@}"

  image="${app}-${part}"
  config="${run}/${part}/config.yaml"
  count=$(yaml get "${config}" count)
  subdomains=$(yaml get "${config}" subdomains)

  # For each swarm node, we need to make sure it has a
  # copy of the image. For a private registry, this
  # doesn't happen automatically, so we have to authenticate
  # to each and pull.

  _pull \
    cluster="${cluster}" \
    image="${image}"

  swarm_env "${cluster}"
  docker_login

  # TODO: this is a hack. We know that if you're
  # setting up subdomains for a part, that you must
  # want to use standard ports. The ports we expose
  # should be based on some additional piece of
  # information (ex: protocols, like we do with
  # discovery), but for the moment, we're just
  # assuming you want port 80. Note that we're
  # terminating TLS at the ELB so you probably
  # don't want to expose 443.
  if [ -n "${subdomains}" ]; then
    port_option="-p 80:80"
  else # just pick a random port
    port_option="-P"
  fi

  # TODO: Refactoring this loop is tricky because
  # all the pieces here are pretty intertwined:
  #
  # - run the docker container
  #
  # - add the private A record for the container
  #
  # - if we want discovery for this container,
  #   add the container and it's port to a list
  #   so we can later add a private SRV record
  #
  # - possibly add the node running the container
  #   to the ELB if it's advertising a subdomain
  #

  for (( i = 0 ; i < ${count:=1} ; i++ )); do

    name="${app}-${part}-$(printf '%02d' $i)"

    docker_run \
      name="${name}" \
      image="${registry}/${image}:latest" \
      options="${port_options}"

    local "$(docker_inspect ${container})"
    local "$(get_instance ${name})"

    # Add private A record for container
    dns_a \
      name="${container}" \
      ip="${ip}" \
      comment="Added by p42 for stack '${cluster}'"

    # save the list of containers so we can set up
    # DNS SRV records later / we only need to do this
    # if discovery is set in the config
    discovery="$(yaml get "${config}" discovery)"
    if [ -n "${discovery}" ]; then
      targets="${targets} ${container} ${port}"
    fi

    # Add to ELB, if applicable, based on subdomains
    if [ -n "${subdomains}" ]; then

      register_instance_with_elb \
        cluster="${cluster}" \
        instance="${id}"

      for subdomain in ${subdomains}; do
          dns_alias \
            cluster="${cluster}" \
            subdomain="${subdomain}" \
            domain="${domain}" \
            comment="Added by p42 for stack '${cluster}'"
      done
    fi
  done

  # Create SRV records for each target,
  # for each protocol the container supports

  for protocol in ${discovery}; do
    dns_srv \
      protocol="${protocol}" \
      public="${part}" \
      targets="${targets}" \
      comment="Added by p42 for stack '${cluster}'"
  done

}

for part in $parts; do
  _run "${part}"
done
