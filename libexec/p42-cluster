#!/usr/bin/env bash

# In several of the functions below, we do the following:
#
#     local "$(load_context)"
#     local "$(options cluster.expand $@)"
#     assert_cluster_exists "${cluster}"
#
# This has the effect of attempting to get the cluster name
# from the command line arguments but falling back to the
# cluster associated with the current branch of the current
# git repo (that is, the one associated with the directory
# we're in), if possible, and exiting with an appropriate
# error message if we can't get a valid cluster name.

include clusters
include machine
include context
include options

_create() {
  local cluster="$(p42 name)"
  create_cluster "${cluster}"
  create_swarm_node \
    cluster="${cluster}" \
    master=true
}

_expand() {
  local "$(load_context)"
  local "$(options cluster.expand $@)"
  assert_cluster_exists "${cluster}"

  for ((i = 0; i < count; i++)); do
    create_swarm_node stack="${cluster}"
  done
}

_contract() {
  echo "Not implemented yet."
}

_rm() {
  local "$(load_context)"
  local "$(options cluster.expand $@)"
  assert_cluster_exists "${cluster}"

  remove_swarm_nodes "${cluster}"
  remove_cluster "${cluster}"
}

_ls() {
  ls "${clusters}"
}

_ps() {
  local "$(load_context)"
  local "$(options cluster.expand $@)"
  assert_cluster_exists "${cluster}"
  list_swarm_nodes "${cluster}"
}

_env() {
  local "$(load_context)"
  local "$(options cluster.expand $@)"
  assert_cluster_exists "${cluster}"
  swarm_env "${cluster}"
}

_get() {
  local "$(load_context)"
  local "$(options cluster.expand $@)"
  assert_cluster_exists "${cluster}"
  yaml get "${clusters}/${cluster}" "${property}"
}

_help() {
  local action="${1}"
  if [ -z "${action}" ]; then
    err "cluster.help"
  else
    declare -F "_${action}" && err "cluster-${action}.help"
    err "cluster.help"
}

action=${1}; shift
declare -F "_${action}" || _help
_${action} ${@}
